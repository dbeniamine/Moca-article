\section{Conclusions}
\label{sec:cncl}

In this study, we addressed the issue of memory accesses collection for
multithreaded applications. This is a key challenge in high performance
computing as memory is often a performance
bottleneck. Memory traces can be used at runtime to improve data locality or
offline by developers to understand and improve their applications memory
behavior and therefore their performances. For online analysis the trace precision
is limited by the number of data that can be analyzed in real time, but for
offline usage, highly accurate traces can provides a better understanding of
the application memory behavior.

To address this challenge, we have proposed \Moca an efficient memory trace
collection system. While other existing tools
rely on \emph{incomplete} hardware sampling to
provide such traces at an acceptable cost, \Moca provides a \emph{complete}
trace, that contains all the accessed areas, at the granularity of the page.
Moreover, \Moca traces not only
contain all pages that are accessed during the execution, but also, 
for each access, they contain temporal, spacial and sharing
information: which thread, accessed what addresses on which CPU and when.
While \Moca works at the page granularity, it stores the exact
address of each intercepted accesses. Therefore, it also provide an
\emph{incomplete} trace at the granularity of the byte, similar to
traces collected by instructions sampling. Furthermore \Moca can also detect
data structure by combining the efficient trace system with a lightweight Pin
instrumentation.

State of the art tools are relying on hardware technologies such as Intel PEBS
or AMD IBS thus embed vendor (or processor) dependent code making them hard
to maintain and not portable. On the contrary \Moca is based on a simple page
fault interception mechanism and does not use any architecture dependent code,
thus it can work on any Linux kernel from $3.0$ without modifications.

We evaluated \Moca by comparing it two state of the art tools: \Mitos and
\MemProf (with their default parameters and with some fine tunning) and one
tool from a previous contribution \TABARNAC. For this comparison we evaluated
two criteria: the precision of the trace and the overhead. We ran our
evaluation on the \NPB which represent multiple situation from simple kernels
to realistic applications. Our evaluation exposed the fact the tools
relying on hardware sampling miss a significant par of the address-space. It
also shown that \Moca was able to provide a complete trace at the page
granularity with a more precise sampling at the byte granularity than the
other tools. Finally \Moca overhead appears to be more important than sampling
base tools but quite comparable to binary instrumentation  based tools.

Future work will focus on the visualization and exploitation of these memory traces
which is another challenge mainly due to the volume of the collected data.
