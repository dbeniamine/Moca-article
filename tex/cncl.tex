\section{Conclusions}
\label{sec:cncl}

In this study, we addressed the issue of memory accesses collection for
multithreaded applications. This is a key challenge in high performance
computing as memory is often a performance
bottleneck. Memory traces can be used at runtime to improve data locality or
offline by developers to understand and improve their applications memory
behavior and therefore their performances. For online analysis the trace precision
is limited by the number of data that can be analyzed in real time, but for
offline usage, highly accurate traces can provides a better understanding of
the application memory behavior.

To address this challenge, we have proposed \Moca an efficient memory trace
collection system. While other existing tools
rely on \emph{incomplete} hardware sampling to
provide such traces at an acceptable cost, \Moca provides a \emph{complete}
trace, that contains all the accessed areas, at the granularity of the page.
Moreover, \Moca traces not only
contain all pages that are accessed during the execution, but also, 
for each access, they contain temporal, spacial and sharing
information: which thread, accessed what addresses on which CPU and when.
While \Moca works at the page granularity, it stores the exact
address of each intercepted accesses. Therefore, it also provide an
\emph{incomplete} trace at the granularity of the byte, similar to
traces collected by instructions sampling. Furthermore \Moca can also detect
data structure by combining the efficient trace system with a lightweight Pin
instrumentation.

Most state of the art tools are relying on hardware technologies such as Intel PEBS
or AMD IBS, thus, embed vendor (or processor) dependent code making them hard
to maintain and not portable. On the contrary, \Moca is based on a simple page
fault interception mechanism and does not use any architecture dependent code.
It can work on any Linux kernel from $3.0$ only by loading a module and
without any kernel modifications.

Several tools uses page fault interception to retrieve information on memory
behavior. As the information provided by only intercepting regular page fault
is not always precise enough, a few tools also generate false page fault
regularly to increase the trace precision. Still at our knowledge, all the
existing tools relying on these mechanisms uses the collected data online and
thus does not have to manage and store large amount of data while \Moca is the
first tool capable of generating \emph{complete} memory traces for offline
analysis.

We evaluated \Moca by comparing it to two state of the art tools: \Mitos and
\MemProf (with their default parameters and with some fine tunning) and one
tool from a previous contribution \TABARNAC. For this comparison, we evaluated
two criteria: the precision of the trace and the overhead. We ran our
evaluation on the \NPB which is representative of multiple kinds of applications from simple kernels
to realistic ones. Our evaluation has exposed the fact that the tools
relying on hardware sampling miss a significant part of the address space. It
has also shown that \Moca is able to provide both a complete trace at the page
granularity and a sampling at the byte granularity significantly more precise than the
other tools. Finally, \Moca overhead appears to be more important than the overhead of sampling
based tools but usually lower than the one induced by binary instrumentation.
Moreover, adding the Pin instrumentation to retrieve date structures
informations does not impact significantly this overhead.

Future work will focus on the visualization and exploitation of these memory traces
which is another challenge mainly due to the volume of the collected data.
