\section{Design}
\label{sec:design}

\subsection{Mainlines}

\Moca consist of a Linux kernel module and a script responsible to launching it
with the right parameters. It does not relies on architecture specific
technologies such as AMD IBS or Intel PEBS, or architecture dependent kernel
code. Therefore it is highly portable and can be run on any recent kernel
(Linux $> 3.X$).

Memory accesses are traced by monitoring page faults moreover, false page
fault are generated by invalidating recently accessed page during the
execution to increase the number of traced accesses. This method have several
advantages over hardware sampling or instrumentation. First it provides a
super set of the accesses: indeed it guarantee that for each page of the
monitored application, at least one access will be traced. Moreover we can
still trace the exact accessed address therefore the granularity is not
limited while instrumentation based tools often works at a high granularity to
keep their overhead reasonable.  Finally trapping to our tool have a very low
cost as it relies on page faults which are triggered by hardware and and Linux
kernel probing mechanism: \emph{kprobes}.

During the execution, we need to store three types of information:
\begin{enumerate}
    \item Which \emph{tasks} (Linux internal representation of threads/processes) are
monitored (as page fault will be triggered by tasks which does not belong to
the monitored application).
    \item Which page faults have been triggered by \Moca (false page faults).
    \item The set of addresses recently accessed by each task.
\end{enumerate}
Each of these informations are stored on preallocated hash maps to reduce the
runtime overhead. The two first are read during every page faults but rarely
written (when a new tasks of the monitored application triggers it first page
fault or when \Moca create some false page faults). Therefore they are
protected with Linux kernel built-in \emph{rwlocks} (with some small
modifications detailed in section \ref{sec:design-tech} for the false page
faults). The third is the actual trace, each task have a private set of
\emph{chunks}. A chunk is a set of accesses that occurred in a time laps. A
monitoring (kernel) thread periodically ends the current chunk of each task
and invalidate every page of these chunks. Finally, a logging process flush
each ended chunks to the disc at a lower frequency. The interaction between
theses entities is detailed in the next section.

Every settings that can influence either the accuracy of the trace or the
overhead of the tools (such as the number and size of chunks, wakeup intervals
for the monitoring thread and the logging process \ldots) are accessible to the
user although the default have been defined after an experimental study
(detailed in section \ref{sec:expe-ovh}).

\subsection{Algorithms and technical issues}
\label{sec:design-tech}

In this section we explain in more details how the main components of \Moca
interact and how we addressed some technical issues.

\begin{algorithm}[htb]
    \caption{Monitoring thread algorithm}
    \label{algo:monTh}
    \begin{algorithmic}[1]
        \While{\Callp{NotFinished}{}}
        \ForAll{t in \Callp{MonitoredTasks}{}}
        \State \Callp{EndCurrentChunk}{t}
                \ForAll{Addr in \Callp{PreviousChunk}{t}}
                    \State \Callp{WriteLockPF}{}
                    \State \Callp{MarkNotPresent}{Addr}
                    \State \Callp{WriteUnlockPF}{}
                \EndFor
            \EndFor
            \State \Callp{sleep}{MonitorThreadWakeUpInterval}
        \EndWhile
    \end{algorithmic}
\end{algorithm}

The monitor thread (kernel thread, algorithm \ref{algo:monTh}) is
responsible to generate false page faults by invalidating
recently accessed pages. The more page faults occurs, the more
precise the trace is. Still to invalidate the page, it needs
to take a write lock on the page faults hashmap. Therefore
delay every pending page fault. The
\texttt{MonitorThreadWakeUpInterval} parameter allows the user
to modify slightly this equilibrium.

\begin{algorithm}[htb]
    \caption{logging process}
    \label{algo:flushTh}
    \begin{algorithmic}[1]
        \While{\Callp{NotFinished}{}}
        \ForAll{t in \Callp{MonitoredTasks}{}}
                \State \Comment{no locks: we work on finished chunks}
                \ForAll{c in \Callp{FinishedChunks}{t}}
                \State \Callp{WriteTraceToDisk}{c}
                \State \Callp{ReinitChunk}{c}
                \EndFor
            \EndFor
            \State \Callp{sleep}{LoggingDaemonWakeupInterval}
        \EndWhile
    \end{algorithmic}
\end{algorithm}

(The logging daemon (algorithm \ref{algo:flushTh}) is a userspace process
which periodically reads \texttt{/proc} pseudo files. Those reads trigger a
callback method in our tool which flush the  from the memory buffers to the
disc. It works on old data therefore does not directly interfere with the
normal application execution. As it generate disc I/O, it is preferable to
keep it asleep most of the time. Still if it does not wake up often enough, no
more chunks will be available to store accesses and a part of the trace will
be lost. It's wakeup interval is settable by the user.

\begin{algorithm}[htb]
    \caption{Page fault handler}
    \label{algo:PageFault}
    \begin{algorithmic}[1]
        \Function{HandlePageFault}{task t,void *addr}
            \If {\Callp{IsNotMonitoredTask}{t}}
                \If {!\Callp{AddToMonitoredIfNeeded}{t}}
                    \State \Comment{Only read locks except if
                    t is Added}
                    \State \Callp{DoPageFault}{}
                    \Comment{Linux handle page fault}
                    \State \Return
                \EndIf
            \EndIf
            \State \Callp{ReadLockPF}{}
            \State \Callp{AddToChunk}{t,addr}
            \Comment{Trace the access}
            \If {!\Callp{TryFixFalsePageFault}{addr}}
                \State \Callp{DoPageFault}{}
                \Comment{Linux handle page fault}
            \EndIf
            \State \Callp{ReadUnlockPF}{}
            \State \Callp{UpdateClock}{}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Every time a page fault occurs, it traps to \Moca (algo
\ref{algo:PageFault}), we first need to determine if the task
(thread or process) responsible for the page fault is
monitored or if we should monitor it. We only need a read lock
to a hashmap containing the monitored tasks to answer these
two questions. If the answer is no, Linux will handle the page
fault normally. The only case will need to take the write lock
is when the second answer is yes (first page fault of a new
monitored task) which occurs quite rarely.

When a monitored task triggers a page fault, we first add the
accessed address to it's current chunk (a.k.a store the fact
then an access occurred, with it's type (read/write) and cpu).
Then we try to ``fix'' the page fault, if it was triggered by
Moca, no work will be necessary for the OS, else we will let
Linux handle the fault normally.

\DB{continue here}
Other suff we should have said:
\begin{itemize}
    \item Few locks as everybody works on different chunks
    \item \texttt{TryFixFalsePageFault} does not remove anything from hashmap
        only mark the entry old which allow to use read locks and keep
        page faults parallel
    \item \texttt{MarkNotPresent}(address)
        \begin{itemize}
            \item Take WriteLock on apgefaults
            \item Removed old hashmap entries if needed
        \end{itemize}
\end{itemize}

\begin{algorithm}[htb]
    \caption{Fair Rwlocks}
    \label{algo:rwlocks}
    \begin{algorithmic}[1]
    \State \textbf{atomic} {$writersWaiting \gets 0$}
    \State \textbf{atomic} $readersWaiting \gets 0$
    \State \textbf{rwlock} $lock$
    \Comment{Linux rwlock (priority to readers)}
    \Function{ReadLockPF}{}
        \State $++readersWaiting$
        \Comment{Block new writers}
        \While{$writersWaiting > 0$}
            \State \Callp{wait}{}
            \Comment{Do not overtake older writer}
        \EndWhile
        \State \Callp{ReadLock}{lock}
        \State $--readersWaiting$
    \EndFunction
    \Function{ReadUnlockPF}{}
        \State \Callp{ReadUnlock}{lock}
    \EndFunction
    \Function{WriteLockPF}{}
        \While{$readersWaiting > 0$}
            \State \Callp{wait}{}
            \Comment{Let their chance to old readers}
        \EndWhile
        \State $++writersWaiting$
        \Comment{Tell next readers to wait}
        \State \Callp{WriteLock}{lock}
        \State $--writersWaiting$
    \EndFunction
    \Function{WriteUnlockPF}{}
        \State \Callp{WriteUnlock}{lock}
    \EndFunction
    \end{algorithmic}
\end{algorithm}

Linux rwlocks advantages readers, for the false page faults hash map, as page
faults occurs very frequently this will result on starvation for the monitor
thread. On the other hand if we advantage writers, page faults will be delayed
while the monitor thread is invalidating page faults and Linux will trigger an
error. Thus we need faire rwlocks for the page faults hash map. We built
low cost fair rwlocks on top of linux rwlocks (algoritm \ref{algo:rwlocks}),
the idea of this mechanism is to forbid a reader to pass an older writter and
conversely.

\subsection{Conclusions}

\begin{itemize}
    \item Efficient design
    \item Portable
    \item Highly tunnable to find optimal trade off between performances and
        trace accuracy
\end{itemize}
