%!TEX encoding=UTF-8 Unicode

\documentclass[10pt, conference, compsocconf]{sty/IEEEtran}

%========================= Encodage fontes et langues =========================

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}

%==============================================================================

%========================= Mise en forme de code ==============================
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{siunitx}

\algblockdefx[]{Function}{EndFunction}
[2]{\algorithmicfunction\ \textproc{#1}{(#2)}}%
{\algorithmicend\ \algorithmicfunction}%


\algnewcommand\Callp[2]{\textproc{#1}(#2)}%

%\algblockdefx[<block>]{<start>}{<end>}
%[<startparamcount>][<default value>]{<start text>}
%[<endparamcount>][<default value>]{<end text>}

\usepackage{listings}
%Langage algorithmique français

\lstset{% general command to set parameter(s)
    basicstyle=\small,
    keywordstyle=\color{BrickRed}\bfseries,
    identifierstyle=,
    commentstyle=\color{blue},
    stringstyle=\ttfamily,
    showstringspaces=false,
    language=C,
    numbers=left, %numérotation des ligne
    stepnumber=1, %à chaque ligne les lignes
    numbersep=10pt, %décalage numéros ligne/ texte
    mathescape=true,%mode math autorisé
    tabsize=4, %tabulation
    frame=single,%encadrement simple
    frameround=tttt,%encadrement
    morecomment=[s][\color{red}]{/*-}{*/},%commentaires spéciaux en rouge
    extendedchars=false,
    breaklines=true,
}

%==============================================================================

% gestion des hyperliens
\usepackage[pdfusetitle]{hyperref}
\hypersetup{
    colorlinks=true, %colore les liens
    breaklinks=true, %permet le retour à la ligne dans les liens trop longs
    urlcolor= blue, %couleur des hyperliens
    linkcolor= black, %couleur des liens internes
    bookmarksopen=true,
    citecolor=black,
}

%==============================================================================

%========================== Images ============================================

\usepackage[]{caption}
\usepackage[]{subcaption}
\usepackage[]{graphicx}
\graphicspath{{./img/}}
\usepackage{multirow,booktabs}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

\usepackage{balance}

%\usepackage{fixltx2e}
%\usepackage{stfloats}
\usepackage{dblfloatfix}
\usepackage{url}
\usepackage{xspace}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,decorations,decorations.pathreplacing,decorations.markings,fit}
\usetikzlibrary{backgrounds,calc}

\pgfdeclarelayer{background}
\pgfdeclarelayer{bg1}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,bg1,main,foreground}

\definecolor{logcolor}{HTML}{FDAE61}
\definecolor{moncolor}{HTML}{FF000A}
\definecolor{pfcolor} {HTML}{3B8ECC}
\definecolor{callcolor}{HTML}{FFFFBF}
\definecolor{dtcolorL}{HTML}{ABD9E9}
\colorlet{dtcolor}{dtcolorL!25}

\tikzstyle{handler} = [rectangle, draw, fill=callcolor,
text width=4em, text badly centered]
\tikzstyle{handlerI} = [diamond, text badly centered]
\tikzstyle{data} = [rectangle, draw, fill=dtcolor,
text width=4em, text centered, rounded corners]
\tikzstyle{Chunk} = [rectangle, draw,rounded corners]
\tikzstyle{dataL} = [rectangle, draw, fill=dtcolorL,
text width=4em, text centered, rounded corners]
\tikzstyle{entity} = [draw, ellipse, text centered,
text width=5em]
\tikzstyle{line} = [very thick,align=center]
\tikzstyle{pf} = [fill=pfcolor,solid]
\tikzstyle{log} = [fill=logcolor,dotted]
\tikzstyle{mon} = [fill=moncolor,dashed]
\tikzstyle{monA} = [-latex,line,dashed,moncolor]
\tikzstyle{pfA} =  [-latex,line,solid,pfcolor]
\tikzstyle{pfAI} =  [line,solid,pfcolor]
\tikzstyle{logA} = [-latex,dotted,line,logcolor]

\tikzset{
  basic box/.style = {
    shape = rectangle,
    draw,
    rounded corners},
  filled box/.style = {
    shape = rectangle,
    draw  = #1,
    fill  = #1,
    rounded corners},
  header node/.style = {
    %Minimum Width = header nodes,
    font          = \strut\large\ttfamily,
    text depth    = +0pt,
    fill          = #1,
    draw},
    header/.style n args={2}{%
    inner ysep = +1.5em,
    append after command = {
      \pgfextra{\let\TikZlastnode\tikzlastnode}
      node [header node=#2] (header-\TikZlastnode) at (\TikZlastnode.north) {#1}
      %node %[span = (\TikZlastnode)(header-\TikZlastnode)]
       % at (fit bounding box) (h-\TikZlastnode) {}
    }
  },
  footer node/.style = {
    %Minimum Width = header nodes,
    font          = \strut\large\ttfamily,
    text depth    = +0pt,
    fill          = #1,
    draw},
    footer/.style n args={2}{%
    inner ysep = +1.5em,
    append after command = {
      \pgfextra{\let\TikZlastnode\tikzlastnode}
      node [header node=#2] (header-\TikZlastnode) at (\TikZlastnode.south) {#1}
      %node %[span = (\TikZlastnode)(header-\TikZlastnode)]
       % at (fit bounding box) (h-\TikZlastnode) {}
    }
  },
  hv/.style = {to path = {-|(\tikztotarget)\tikztonodes}},
  vh/.style = {to path = {|-(\tikztotarget)\tikztonodes}},
  fat blue line/.style = {ultra thick, blue}
}




%==============================================================================


\usepackage[obeyDraft]{todonotes}
%\usepackage{todonotes}
\newcommand{\DB}[1]{\todo[author=David,inline]{#1}}
\newcommand{\GH}[1]{\todo[author=Guillaume,inline]{#1}}

\newcommand{\Input}[1]{\input{tex/#1}}
\newcommand{\Moca}{\emph{Moca}\xspace}
\newcommand{\MocaPin}{\emph{MocaPin}\xspace}
\newcommand{\Mitos}{\emph{Mitos}\xspace}
\newcommand{\MitosTun}{\emph{MitosTun}\xspace}
\newcommand{\TABARNAC}{\emph{Tabarnac}\xspace}
\newcommand{\MemProf}{\emph{MemProf}\xspace}
\newcommand{\MemProfTun}{\emph{MemProfTun}\xspace}
\newcommand{\NPB}{\emph{NAS parallel benchmarks}\xspace}
% Bench
\newcommand{\FT}{\texttt{FT}\xspace}
\newcommand{\BT}{\texttt{BT}\xspace}
\newcommand{\IS}{\texttt{IS}\xspace}
\newcommand{\DC}{\texttt{DC}\xspace}
\newcommand{\MG}{\texttt{MG}\xspace}
\newcommand{\LU}{\texttt{LU}\xspace}
\newcommand{\UA}{\texttt{UA}\xspace}
\newcommand{\EP}{\texttt{EP}\xspace}
\newcommand{\SP}{\texttt{SP}\xspace}
\newcommand{\CG}{\texttt{CG}\xspace}
% Machines
\newcommand{\Edel}{\texttt{Edel}\xspace}
\newcommand{\Idfreeze}{\texttt{Idfreeze}\xspace}
\newcommand{\Stremi}{\texttt{St~Remi}\xspace}
% Figures and tables
\newcommand{\fig}[1]{Figure~\ref{fig:#1}}
\newcommand{\tbl}[1]{Table~\ref{tab:#1}}

\hyphenation{over-view}
% Avoid page break on footnotes:
\interfootnotelinepenalty=10000
%\clubpenalty=10000
%\widowpenalty=10000
%==============================================================================

%========================= Titre auteur etc ===================================
\title{Moca: An efficient Memory trace collection system}
\author{\IEEEauthorblockN{David Beniamine, Guillaume Huard}
\IEEEauthorblockA{Univ. Grenoble Alpes, LIG, F-38000 Grenoble, France\\
CNRS, LIG, F-38000 Grenoble, France\\
Inria\\
%<firstname>.<lastname>@imag.fr}
\{David.Beniamine,Guillaume.Huard\}@Imag.fr}
}


%==============================================================================

\begin{document}


\maketitle

\begin{abstract}

    In modern \emph{High Performance Computing} architectures, the memory subsystem
    is a common performance bottleneck. When optimizing an application, the developer has to
    study its memory access patterns and adapt accordingly the algorithms and data structures it uses.
    The objective is twofold: on one hand, it is necessary to avoid missuses of the memory hierarchy such as false sharing of cache lines or contention in a NUMA
    interconnect. On the other hand, it is essential to take advantage of the various cache levels and the memory hardware prefetcher. 
    %To take advantage from the cache, % or from hardware optimization mechanisms such as
    %the memory prefetcher or the NUMA interconnect, the developer has to study the memory accesses
    %patterns of his application and optimize it for locality and linearity.

    Still, most profiling tools focus on CPU metrics. The few of them able to
    provide an overview of the memory patterns involved by the execution rely on hardware instrumentation mechanisms and have two drawbacks.
    The first one is that they are based on sampling which precision is limited by hardware capabilities. The second one is that they trace 
    a subset of all the memory accesses, usually the most frequent, without information about the other ones.

    In this study we present \Moca an efficient tool for the collection of \emph{complete} spatiotemporal memory traces.
    It is based on a Linux kernel module and provides a trace which is a sample of all the memory accesses performed by the monitored application.
    The interesting characteristic of \Moca is that it guarantees that the trace is \emph{complete} regarding memory pages: for each basic time interval, the trace
    contains one sample for each page accessed by the application.
    The overhead of \Moca is reasonable when taking into account the fact that
    it is able to collect traces that are both \emph{complete} and more precise
    than the ones collected by comparable tools.

\end{abstract}

\DB{
    Clusters 10 pages \url{http://www.ieeecluster2016.org/AuthorInformation.html/}
\\
track:\\
Appli, algo and lib: ``Performance modeling and measurement'' ``Performance
evaluation tools'' \\
subimissionss: \url{https://ssl.linklings.net/conferences/ieeecluster/}
}
%\listoftodos
\Input{intro.tex}
\Input{related.tex}
\Input{design.tex}
\Input{experiment.tex}
\Input{cncl.tex}
\section*{Acknowledgements}
Experiments presented in this paper were carried out using the Grid'5000
experimental testbed, being developed under the INRIA ALADDIN development
action with support from CNRS, RENATER and several Universities as well
s other funding bodies (see \url{https://www.grid5000.fr}).

\bibliographystyle{sty/IEEEtranBST/IEEEtran}
\balance
\bibliography{biblio}
\end{document}

