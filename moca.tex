%!TEX encoding=UTF-8 Unicode

\documentclass[10pt, conference, compsocconf]{sty/IEEEtran}

%========================= Encodage fontes et langues =========================

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}

%==============================================================================

%========================= Mise en forme de code ==============================
\usepackage{algorithm}
\usepackage{algpseudocode}

\algblockdefx[]{Function}{EndFunction}
[2]{\algorithmicfunction\ \textproc{#1}{(#2)}}%
{\algorithmicend\ \algorithmicfunction}%


\algnewcommand\Callp[2]{\textproc{#1}(#2)}%

%\algblockdefx[<block>]{<start>}{<end>}
%[<startparamcount>][<default value>]{<start text>}
%[<endparamcount>][<default value>]{<end text>}

\usepackage{listings}
%Langage algorithmique français

\lstset{% general command to set parameter(s)
    basicstyle=\small,
    keywordstyle=\color{BrickRed}\bfseries,
    identifierstyle=,
    commentstyle=\color{blue},
    stringstyle=\ttfamily,
    showstringspaces=false,
    language=C,
    numbers=left, %numérotation des ligne
    stepnumber=1, %à chaque ligne les lignes
    numbersep=10pt, %décalage numéros ligne/ texte
    mathescape=true,%mode math autorisé
    tabsize=4, %tabulation
    frame=single,%encadrement simple
    frameround=tttt,%encadrement
    morecomment=[s][\color{red}]{/*-}{*/},%commentaires spéciaux en rouge
    extendedchars=false,
    breaklines=true,
}

%==============================================================================

% gestion des hyperliens
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %colore les liens
    breaklinks=true, %permet le retour à la ligne dans les liens trop longs
    urlcolor= blue, %couleur des hyperliens
    linkcolor= black, %couleur des liens internes
bookmarksopen=true}

%==============================================================================

%========================== Images ============================================

\usepackage[]{caption}
\usepackage[]{graphicx}
\graphicspath{{./img/}}
\usepackage{multirow,booktabs}
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

\usepackage{balance}

%\usepackage{fixltx2e}
%\usepackage{stfloats}
\usepackage{dblfloatfix}
\usepackage{url}
\usepackage{xspace}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,decorations,decorations.pathreplacing,decorations.markings,fit}
\usetikzlibrary{backgrounds,calc}

\pgfdeclarelayer{background}
\pgfdeclarelayer{bg1}
\pgfdeclarelayer{foreground}
\pgfsetlayers{background,bg1,main,foreground}

\definecolor{logcolor}{HTML}{FDAE61}
\definecolor{moncolor}{HTML}{D7191C}
\definecolor{pfcolor} {HTML}{2C7BB6}
\definecolor{callcolor}{HTML}{FFFFBF}
\definecolor{dtcolorL}{HTML}{ABD9E9}
\colorlet{dtcolor}{dtcolorL!25}

\tikzstyle{handler} = [diamond, draw, fill=callcolor,
text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{handlerI} = [diamond,
text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{data} = [rectangle, draw, fill=dtcolor,
text width=5em, text centered, rounded corners, node distance=3cm, minimum height=4em]
\tikzstyle{Chunk} = [rectangle, draw,rounded corners]
\tikzstyle{dataL} = [rectangle, draw, fill=dtcolorL,
text width=5em, text centered, rounded corners, node distance=3cm, minimum height=4em]
\tikzstyle{entity} = [draw, ellipse,node distance=3cm,text centered,
text width=5em,minimum height=2em]
\tikzstyle{line} = [very thick,align=center]
\tikzstyle{pf} = [fill=pfcolor,solid]
\tikzstyle{log} = [fill=logcolor,dotted]
\tikzstyle{mon} = [fill=moncolor,dashed]
\tikzstyle{monA} = [->,line,dashed,moncolor]
\tikzstyle{pfA} =  [->,line,solid,pfcolor]
\tikzstyle{pfAI} =  [line,solid,pfcolor]
\tikzstyle{logA} = [->,dotted,line,logcolor]

\tikzset{
  basic box/.style = {
    shape = rectangle,
    draw,
    rounded corners},
  filled box/.style = {
    shape = rectangle,
    draw  = #1,
    fill  = #1,
    rounded corners},
  header node/.style = {
    %Minimum Width = header nodes,
    font          = \strut\Large\ttfamily,
    text depth    = +0pt,
    fill          = #1,
    draw},
    header/.style n args={2}{%
    inner ysep = +1.5em,
    append after command = {
      \pgfextra{\let\TikZlastnode\tikzlastnode}
      node [header node=#2] (header-\TikZlastnode) at (\TikZlastnode.north) {#1}
      %node %[span = (\TikZlastnode)(header-\TikZlastnode)]
       % at (fit bounding box) (h-\TikZlastnode) {}
    }
  },
  hv/.style = {to path = {-|(\tikztotarget)\tikztonodes}},
  vh/.style = {to path = {|-(\tikztotarget)\tikztonodes}},
  fat blue line/.style = {ultra thick, blue}
}




%==============================================================================


\usepackage{todonotes}
\newcommand{\DB}[1]{\todo[author=David,inline]{#1}}
\newcommand{\GH}[1]{\todo[author=Guillaume,inline]{#1}}

\newcommand{\Input}[1]{\input{tex/#1}}
\newcommand{\Moca}{\emph{MOCA}\xspace}
% Bench
\newcommand{\FT}{\texttt{FT}}
\newcommand{\BT}{\texttt{BT}}
\newcommand{\IS}{\texttt{IS}}
\newcommand{\DC}{\texttt{DC}}
\newcommand{\MG}{\texttt{MG}}
\newcommand{\LU}{\texttt{LU}}
\newcommand{\UA}{\texttt{UA}}
\newcommand{\EP}{\texttt{EP}}
\newcommand{\SP}{\texttt{SP}}
\newcommand{\CG}{\texttt{CG}}
%==============================================================================

%========================= Titre auteur etc ===================================
\title{Moca: An efficient Memory trace collection system}
\author{\IEEEauthorblockN{David Beniamine, Guillaume Huard}
\IEEEauthorblockA{Univ. Grenoble Alpes, LIG, F-38000 Grenoble, France\\
CNRS, LIG, F-38000 Grenoble, France\\
Inria\\
%<firstname>.<lastname>@imag.fr}
\{David.Beniamine,Guillaume.Huard\}@Imag.fr}
}


%==============================================================================

\begin{document}


\maketitle

\begin{abstract}
    In modern \emph{High Performance Computing} architectures, memory accesses
    are a common bottleneck. To benefit from hardware optimization mechanisms
    such as cache pre-fetcher, the developer needs to consider memory access
    pattern trying to improve locality and linearity.

    Most efforts on memory performances optimization at software level relies
    on adaptive tools which move data or thread on the CPUs at the runtime to
    reduce communication times. Such tools are often efficient but cannot
    modify an application's memory access pattern thus the developer still
    have to consider the memory behavior to benefit from them.

    While a lots of tools have been developed to measure an application's
    performances, most of them focus on the CPU and none of them is able to
    provide an overview of the memory accesses. Such an overview can help the
    developer optimizing its application memory behavior resulting in
    significant performance gain.

    In this study we present \Moca an efficient software level memory trace
    collection system that provide a complete overview of an applications
    memory behaviour over the time. We evaluate \Moca overhead and we compare
    it to existing tools in terms of performances and trace details.

\end{abstract}

\listoftodos
\Input{intro.tex}
\Input{related.tex}
\Input{design.tex}
\Input{experiment.tex}
\Input{cncl.tex}
\section*{Acknowledgements}
Experiments presented in this paper were carried out using the Grid'5000
experimental testbed, being developed under the INRIA ALADDIN development
action with support from CNRS, RENATER and several Universities as well
s other funding bodies (see \url{https://www.grid5000.fr}).

\bibliographystyle{sty/IEEEtranBST/IEEEtran}
\balance
\bibliography{biblio}
\end{document}

